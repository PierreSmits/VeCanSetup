#!/bin/bash

# setup for CANbus with CANable and other 3rd party interfaces

# installs shell scripts and udev rules

# run manually initally, then called from reinstallMods
# run manually with "uninstall" as first parameter to restore components to stock

# installs CAN dBus services
# ports is a space-separated list of possible VE.can ports
# all services in the servcies list are created for each port

# This script will NOT change factory CAN ports !!!!
# but it would be possible to add a port to say a CCGX


displayPortsList="can0 can1"
services="can-bus-bms vecan-dbus mqtt-n2k dbus-valence dbus-motordrive"

venusDir=/opt/victronenergy
veCanPortsFile=/etc/venus/canbus_ports

udevRulesDir="/etc/udev/rules.d"

binDir=/usr/local/bin

# no log file
packageLogFile=""

#### following lines incorporate SetupHelper utilities into this script
# Refer to the SetupHelper ReadMe file for details.

source "/data/SetupHelper/CommonResources"

#### end of lines to include SetupHelper

overlaysOK=false
stockPortsList=""

# check machine type so changing built-in CAN ports can be avoided
if [ -f /etc/venus/machine ]; then
    machine=$(cat /etc/venus/machine)
    case $machine in
        raspberrypi*)
            configFile="/u-boot/config.txt"
            portsList="can0 can1"
            gxDevice="Raspberry PI - no built-in CAN ports"
            ;;
        einstein)
            configFile=""
            portsList=""
            gxDevice="Cerbo GX - 2 built-in CAN ports"
            ;;
        beaglebone)
            configFile=""
            portsList=""
            gxDevice="Venus GX - 2 CAN ports"
            ;;
        ccgx)
            configFile=""
            portsList="can1"
            ;;
        *)
            gxDevice="unsupported Venus device type $machine - changes not allowed"
            configFile=""
            portsList=""
        ;;
    esac
else
    logMessage "can't determine Venus device type - exiting"
    exit
fi

reversePortsList=$(echo $portsList | tr ' ' '\n' | sort -r | tr '\n' ' ')


# CAN interfce templates - must be set after sourcing CommonResources
templatesDir="$scriptDir/templates"

changesPending=false

# this function collects udev info for the port specified in $1

collectUdevInfo ()
{
        udevPath=$(udevadm info -e | grep $1 | grep P: | awk '{print $2}')
        if [ ! -z $udevPath ]; then
            udevadm info -q all -p "$udevPath" > "$scriptDir/tmp"
            udevModelId=$(grep ID_MODEL_ID "$scriptDir/tmp" | awk -F= '{print $2}')
            udevSerial=$(grep ID_SERIAL_SHORT "$scriptDir/tmp" | awk -F= '{print $2}')
            udevVendor=$(grep ID_VENDOR "$scriptDir/tmp" | grep -v ENC | grep -v FROM | grep -v _ID | awk -F= '{print $2}')
            udevVendorId=$(grep ID_VENDOR_ID "$scriptDir/tmp" | awk -F= '{print $2}')
            rm -f "$scriptDir/tmp"
            udevInfoValid=true
        else
            udevModelId=""
            udevSerial=""
            udevVendor=""
            udevVendorId=""
            udevInfoValid=false
       fi
}


# this function reports to the console information about VeCan ports
# identified in the canports file

reportVeCanInfo ()
{
    echo
    for port in $displayPortsList ; do
        echo "information for $port"
        collectUdevInfo $port
        if $udevInfoValid ; then
            echo "  udev info  vendor=$udevVendor  model Id=$udevModelId  vendor id=$udevVendorId  serial=$udevSerial"
        else
            echo "  no udev information available"
        fi
        
        /bin/echo -n "  overlay: "
        if [ ! -z "$configFile" ]; then
            grep "$port" "$configFile" | grep -v "#"
            if [ $? == 1 ]; then
                echo "none"
            fi
        else
            echo "none"
        fi

        /bin/echo -n "  services: "        
        services=$(cd $serviceDir; ls -d *$port 2>/dev/null)
        if [ $? == 0 ]; then
            echo $services
        else
            echo "none"
        fi
    done
}

# collects port information and stores it in the $portInfoText varable
#
# $1 is the port identifier (e.g., can0)

getPortInfo ()
{
    portConfigDir="$setupOptionsDir/$1.config"
    if [ -d "$portConfigDir" ] && [ -f "$portConfigDir/description" ]; then
        portInfoText=$(cat "$portConfigDir/description")
    elif [ -e  "$veCanPortsFile" ] && [ $(grep -c "$1" "$veCanPortsFile") != 0 ]; then
        portInfoText="could be CONFIGURED ELSEWHERE"
    else
        portInfoText="no configuration"
    fi
}

displayPorts ()
{
    for port in $displayPortsList ; do
        getPortInfo $port
        echo "$port $portInfoText"
    done
}


# updates the local (persistent) copy of the CANbus port
# This information is then used during an install (manual) or reinstall (boot-time automatic)

# $1 is the port (e.g., "can0) to be updated/created

updateConfiguration ()
{
    port=$1
    # display device type list
    deviceTypes=($(ls -d "$templatesDir"/*))
    index=0
    echo
    while true; do
        deviceDir=${deviceTypes[$index]}
        if [ -z "$deviceDir" ]; then
            break
        fi
        description=$(cat "$deviceDir/description")
        ((itemNo = index + 1))
        echo "$itemNo) $description"
         ((index++))
    done

    configUpdated=false
    echo
    /bin/echo -n "Choose a device type for $port from the list above (by number) (cr for no change): "
    read response
    case $response in
        [0-9]*)
            configUpdated=true
            ;;
        *)
    esac

    if ! $configUpdated ; then
        echo
        echo "configuration was NOT updated/added"
        return
    fi

    ((index = response - 1 ))
    deviceDir=${deviceTypes[$index]}
    description=$(cat "$deviceDir/description")

    #copy template directory to config for this port
    baseName=$(basename "$deviceDir")
    if [ ! -e "$templatesDir/$baseName" ]; then
        logMessage "ERROR template $baseName not found - can't create file set for $port"
        configUpdated=false
       return
    fi

    # here update/create configuration
    portConfigDir="$setupOptionsDir/$port.config"

    rm -rf "$portConfigDir"
    cp -r "$templatesDir/$baseName" "$portConfigDir"
    
    # personalize overlay for port
    overlayFile="$portConfigDir/overlay"
    if [ -f "$overlayFile" ]; then
        sed -i -e s/DEV/$port/ "$overlayFile"
    fi

    # personalize scripts
    addScript="$portConfigDir/add.sh"
    removeScript="$portConfigDir/add.sh"
    if [ -f "$addScript" ] || [ -f "$removeScript" ]; then
        logMessage "personalizing udev scripts for $port"
        if [ -f "$addScript" ]; then
            sed -i -e s/DEV/$port/ "$addScript"
        fi
        if [ -f "$removeScript" ]; then
            sed -i -e s/DEV/$port/ "$removeScript"
        fi
    fi
    
    udevRulesFile="$portConfigDir/udevRules"
    if [ -f "$udevRulesFile" ]; then
        logMessage "personalizing udev rules for $port"
        sed -i -e s/DEV/$port/ "$udevRulesFile"

        # serial number in udev rules - optionally needs filling in
        if [ $(grep -c 'ATTRS{serial}' "$udevRulesFile") != 0 ]; then
            collectUdevInfo $port
            serialNumber=""
            # try this port's udev info first
            if $udevInfoValid ; then
                echo "$1 udev info  vendor=$udevVendor  model Id=$udevModelId  vendor id=$udevVendorId  serial=$udevSerial"
                if [ ! -z "$udevSerial" ]; then
                    yesNoPrompt "use this serial number (y/n)?: "
                    if $yesResponse ; then
                        serialNumber="$udevSerial"
                    fi
                fi
            fi
            # next, look in dmesg
            if [ -z "$serialNumber" ]; then
                modelId=$(sed -n -e '/ACTION/,/ACTION/p' "$udevRulesFile"\
                            | grep 'ID_MODEL_ID' | awk '-F\"' '{print $2}')
                if [ ! -z "$modelId" ]; then
                    dmesg > "$scriptDir/dmesgTmp"
                    device=$(grep $modelId "$scriptDir/dmesgTmp" | awk '-F[\]:]' '{print $2}')
                    if [ ! -z "$device" ]; then
                        dmesgInfo=$(grep "$device" "$scriptDir/dmesgTmp"  | grep "SerialNumber:")
                        if [ ! -z "$dmesgInfo" ] ; then
                            echo found this in dmesg: $dmesgInfo
                            yesNoPrompt "use that serial number (y/n)?: "
                            if $yesResponse ; then
                                serialNumber=$(echo "$dmesgInfo" | awk -F: '{print $3}' | xargs)
                            fi
                        fi
                    fi
                    rm -f "$scriptDir/dmesgTmp"
                fi
            fi
            # prompt for serial number
            if [ -z $serialNumber ]; then
                /bin/echo -n "enter serial number manually (cr for none): "
                read serialNumber
            fi
            if [ ! -z $serialNumber ]; then
                logMessage "adding serial number $serialNumber to $port udev rules"
                sed -i -e s/ATTRS{serial}==\"\"/ATTRS{serial}==\"$serialNumber\"/ "$udevRulesFile"
            else
                logMessage "removing serial number from $port udev rules"
                sed -i -e '/ATTRS{serial}/ d' "$udevRulesFile"
            fi
        fi
    fi
    echo "$port configuration updated"
    changesPending=true
}


# looks for configurations to be added, modified or removed
# multile configurations may be updated without returning to the main menu
# configurations must be added in assending order, that is you can't create can1 before can0
# and removed in reverse order so that can0 is the first one added, the last one removed
# and no gaps (e.g., can0, can3 not allowed)
# modifications to the local configuration does not install/activate them!

addConfiguration ()
{
    # find first port without a configuration
    selectedPort=""
    for port in $portsList ; do
        portConfigDir="$setupOptionsDir/$port.config"
        if [ ! -e $portConfigDir ]; then
            updateConfiguration $port
            if ! $configUpdated ; then
                return
            fi
        fi
    done
    echo "no more configurations can be added"
}

modifyConfiguration ()
{
    selectedPort=""
    for port in $portsList ; do
        portConfigDir="$setupOptionsDir/$port.config"
        if [ -e $portConfigDir ]; then
            echo
            getPortInfo $port
            yesNoPrompt "modify $port $portInfoText (y/n)?: "
            if $yesResponse ; then
                updateConfiguration $port
            fi
        fi
    done
    echo "no more configurations to be modified"
}


removeConfiguration ()
{
    for port in $reversePortsList ; do
        configFound=false
        portConfigDir="$setupOptionsDir/$port".config
        if [ -e "$portConfigDir" ]; then
            configFound=true

            getPortInfo $port
            echo
            yesNoPrompt "remove $port $portInfoText (y/n)?: "
            if $yesResponse ; then
                logMessage "removing confituration for $port"
                rm -rf "$portConfigDir"
                changesPending=true
            # didn't remove this interface so can't do any more
            else
                break;
            fi
        fi
    done
    if ! $configFound ; then
        echo "all configurations have been removed"
    fi
}


#### running manually - prompt for input
if [ $scriptAction == 'NONE' ] ; then

    if [ -f "$setupOptionsDir/optionsSet" ]; then
        enableReinstall=true
    else
        enableReinstall=false
    fi

    # display innitial message
    
    response=''
    displayMessage=true
    while true; do
        echo
        echo "$gxDevice"
        echo "VeCan configurations"
        displayPorts
        if $changesPending ; then
            echo
            echo "changes are NOT active yet"
            echo "select INSTALL when all changes have been made and verified"
        fi
        if $displayMessage ; then
            echo
            echo "Available actions:"
            echo "  Add interface configurations (a)"
            echo "  Modify interface configurations (m)"
            echo "  Remove interface configurations (x)"
            echo
            echo "  Install and activate interfaces (i)"
            if $enableReinstall ; then
                echo "  Reinstall (r) based on options provided at last install"
            fi
            echo "  Uninstall (u) and restore all files to stock"
            echo
            echo "  Display interface information (d)"
            echo "  Display setup log (l) outputs the last 100 lines of the log"
            echo "  Quit (q) without further action"
        fi

        echo
        /bin/echo -n "Choose an action from the list above: "
        read response
        displayMessage=false
        case $response in
            [aA]*)
                addConfiguration
                ;;
            [mM]*)
                modifyConfiguration
                ;;
            [xX]*)
                removeConfiguration
                ;;
            [iI]*)
                scriptAction='INSTALL'
                break
                ;;
            [rR]*)
                if $enableReinstall ; then
                    scriptAction='INSTALL'
                    break
                fi
                ;;
            [uU]*)
                scriptAction='UNINSTALL'
                break
                ;;
            [dD]*)
                reportVeCanInfo
                ;;
            [lL]*)
                displayLog $setupLogFile
                ;;
            [qQ]*)
                break
                ;;
            *)
                displayMessage=true
                ;;
        esac
    done
fi


# updateCanFiles either installs or removes files associted with each port
# the install/remove decision is based on the presence of a file set for each port
# a package uninstall ignores the file sets and removes the port files
# as well as restoring the VeCan ports file to stock

updateCanFiles ()
{
    # start with empty canbus_ports temp file
    cat "" > "$scriptDir/tempPorts"
    
    for port in $portsList; do
        # treat uninstall as if there is nothing specified for the port
        # all files for all ports will be removed/restored
        if [ $scriptAction == 'UNINSTALL' ] ; then
            portDefined=false
        else
            portConfigDir="$setupOptionsDir/$port".config
            if [ -e "$portConfigDir" ]; then
                portDefined=true
            else
                portDefined=false
            fi
        fi

        # update temp copy of VeCan ports file
        if $portDefined ; then
            echo "$port" >> "$scriptDir/tempPorts"
        fi

        if $portDefined && [ ! -e $binDir ]; then
            logMessage "creating $binDir"
            mkdir $binDir
        fi

        if $portDefined && [ -f "$portConfigDir/add.sh" ]; then
            updateActiveFile "$portConfigDir/add.sh" "$binDir/$port"add.sh
        else
            restoreActiveFile "$binDir/$port"add.sh
        fi
        if $portDefined && [ -f "$portConfigDir/remove.sh" ]; then
            updateActiveFile "$portConfigDir/remove.sh" "$binDir/$port"remove.sh
        else
            restoreActiveFile "$binDir/$port"remove.sh
        fi
        if $portDefined && [ -f "$portConfigDir/udevRules" ]; then
            updateActiveFile "$portConfigDir/udevRules" "$udevRulesDir/$port".rules
        else
            restoreActiveFile "$udevRulesDir/$port".rules
        fi

        # add/remove overlay to/from config.txt - if adding, need to remove a previous one first
        if [ ! -z "$configFile" ]; then
            overlayExists=false
            if [ -f "$configFile" ]; then
                if [ $(grep -c "#### begin CAN overlay $port" "$configFile") != 0 ]; then
                    overlayExists=true
                    oldOverlayText=$(grep dtoverlay "$configFile")
                fi
            fi
            if $portDefined && [ -f "$portConfigDir/overlay" ]; then
                installOverlay=true
                newOverlayText=$(grep dtoverlay "$portConfigDir/overlay")
            else
                installOverlay=false
            fi
            # correct overlay already installed - don't make changes
            if $overlayExists && $installOverlay ; then
                if [ "$oldOverlayText" == "$newOverlayText" ]; then
                  overlayExists=false
                  installOverlay=false
                fi
            fi
            if $overlayExists ; then
                logMessage "removing CAN overlay for $port from config.txt"
                sed -i -e "/#### begin CAN overlay $port/,/#### end CAN overlay/d" "$configFile"
                rebootNeeded=true
            fi
            if $installOverlay ; then
                logMessage "adding overlay for $port to config.txt"
                cat "$portConfigDir/overlay" >> $configFile
                rebootNeeded=true
            fi
        fi
        # add service if port is active and if service does not already exist
        for service in $services; do
            if $portDefined ; then
                destDir="$serviceDir/$service.$port"
                if [ ! -d "$destDir" ]; then
                    serviceTemplate="$venusDir/service-templates/$service"
                    tempServiceDir="$scriptDir/tempService.$port"
                    # template exists (v2.80 and beyond), take service source from there
                    if [ -d "$serviceTemplate" ]; then
                        srcDir="$venusDir/service-templates/$service"
                    # otherwise assume service template is in the service's main directory
                    else
                        srcDir="$venusDir/$service/service"
                    fi
                    if [ -d "$srcDir" ] ; then
                        logMessage "creating $service.$port"
                        cp -r "$srcDir" "$tempServiceDir"
                        sed -i -e s/DEV/$port/ "$tempServiceDir/run"
                        sed -i -e s/DEV/$port/ "$tempServiceDir/log/run"
                        rm -rf  "$serviceDir/$service.$port"
                        mv "$tempServiceDir" "$destDir"
                        filesUpdated=true
                    fi
                fi
            fi
        done

    done

    if [ $scriptAction == 'UNINSTALL' ]; then
        restoreActiveFile "$veCanPortsFile"
    else
        updateActiveFile "$scriptDir/tempPorts" "$veCanPortsFile" 
    fi
    rm -f "$scriptDir/tempPorts"

    changesPending=false
}


#### installling
if [ $scriptAction == 'INSTALL' ] ; then
    logMessage "installing package"
    updateCanFiles
fi

# uninstalling - check scriptAction again
# if an install step failed package needs to be removed
if [ $scriptAction == 'UNINSTALL' ] ; then

    logMessage "uninstalling package"
    updateCanFiles
fi

if ! $runningAtBoot ; then
    echo
    echo "revised information"
    displayPorts
    reportVeCanInfo
    if $changesPending ; then
        echo
        echo "updated configurations have NOT been installed and activated"
        echo "rerun the script and select INSTALL"
    fi
    if $filesUpdated || $rebootNeeded ; then
        echo
        echo "new interfaces will not become active until after a reboot"
        rebootNeeded=true
    fi
fi

# thats all folks - SCRIPT EXITS INSIDE THE FUNCTION
endScript
